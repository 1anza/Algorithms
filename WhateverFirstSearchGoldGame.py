# -*- coding: utf-8 -*-
"""PS5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EaXZ_EuPaGNBReM_H8AU90mYQKwXa2-g
"""

# input elements
wh = list(map(int, input().split())) 

# num of cols
w = wh[0]

# num of rows
h = wh[1]

xAxis = 0
yAxis = 0
val = [[0 for x in range(w)] for y in range(h)]

for i in range(0,h):
  inp = input()
  char = [*inp]
  for j in range(0, w):
    val[i][j] = char[j]
    if val[i][j] == 'P':
      xAxis = i
      yAxis = j

def getGold(graph, position):
  gold = 0
  while position:
    i, j = position.pop()

    if graph[i][j] != 'none':

      if graph[i][j] == "G":
        gold = gold + 1

      graph[i][j] = 'none'
      arr = []

      if graph[i-1][j] == 'T' or graph[i+1][j] == 'T' or graph[i][j-1] == 'T' or graph[i][j+1] == 'T':
        continue
        
      if i > 0 and (graph[i-1][j] == '.' or graph[i-1][j] == 'G'):
        arr.append((i-1, j))

      if i < h and (graph[i+1][j] == '.' or graph[i+1][j] == 'G'):
        arr.append((i+1, j))

      if j > 0 and (graph[i][j-1] == '.' or graph[i][j-1] == 'G'):
        arr.append((i, j-1))

      if j < w and (graph[i][j+1] == '.' or graph[i][j+1] == 'G'):
        arr.append((i, j+1))

      position += arr

  return gold

start = [(xAxis, yAxis)]
print(getGold(val,start))



# create a priority queue and hash set to store visited nodes
    queue, visited = [(0, source, [])], set()
    heapq.heapify(queue)
    # traverse graph with BFS
    while queue:
        (cost, node, path) = heapq.heappop(queue)
        # visit the node if it was not visited before
        if node not in visited:
            visited.add(node)
            path = path + [node]
            # hit the sink
            if node == sink:
                return (cost, path)
            # visit neighbours
            for c, neighbour in graph[node]:
                if neighbour not in visited:
                    heapq.heappush(queue, (cost+c, neighbour, path))
    return float("inf")



from collections import defaultdict
def shortestPath(edgelist, start_node):
    graph = defaultdict(list)
    # build the DAG
    for a, b, v in edgelist:
        graph[a].append((b, v))

    # topological sort
    def topoSort(node, stack, visited):
        visited.add(node)
        for child, weight in graph[node]:
            if child not in visited:
                topoSort(child, stack, visited)
        stack.append(node)
    
    stack = []
    visited = set()
    nodes = list(graph.keys())
    for node in nodes:
        if node not in visited:
            topoSort(node, stack, visited)
            
    # relaxation
    distance = {vertex:float('inf') for vertex in graph} 
    distance[start_node] = 0
    while stack:
        node = stack.pop()
        
        for child, weight in graph[node]:
            distance[child] = min(distance[node] + weight, distance[child])
            
    return distance


edgelist = [(0, 1, 5),
(0, 2, 3),
(1, 3, 6),
(1, 2, 2),
(2, 4, 4),
(2, 5, 2),
(2, 3, 7),
(3, 4, -1),
(4, 5, -2)]

d = shortestPath(edgelist, 1)
print(d)
# {0: inf, 1: 0, 2: 2, 3: 6, 4: 5, 5: 3}



# A class to represent a graph object
class Graph:
    # Constructor to construct a graph
    def __init__(self, edges, n):

        # A list of lists to represent an adjacency list
        self.adjList = [[] for _ in range(n)]
 
        # add edges to the directed graph
        for (src, dest, weight) in edges:
            # allocate node in adjacency list from src to dest
            self.adjList[src].append((dest, weight))
 
# Perform DFS on the graph and set the departure time of all
# vertices of the graph
def DFS(graph, v, discovered, departure, time):
 
    # mark the current node as discovered
    discovered[v] = True
 
    # set the arrival time of vertex `v`
    time = time + 1
 
    # do for every edge (v, u)
    for u in graph.adjList[v]:
        # if `u` is not yet discovered
        if not discovered[u]:
            time = DFS(graph, u, discovered, departure, time)
 
    # ready to backtrack
    # set departure time of vertex `v`
    departure[time] = v
    time = time + 1
 
    return time

# Function to perform a topological sort on a given DAG
def doTopologicalSort(graph, n):
 
    # departure[] stores the vertex number using departure time as an index
    departure = [-1] * 2 * n
 
    ''' If we had done it the other way around, i.e., fill the array
        with departure time using vertex number as an index, we would
        need to sort it later '''
 
    # to keep track of whether a vertex is discovered or not
    discovered = [False] * n
    time = 0
 
    # perform DFS on all undiscovered vertices
    for i in range(n):
        if not discovered[i]:
            time = DFS(graph, i, discovered, departure, time)
 
    # Print the vertices in order of their decreasing
    # departure time in DFS, i.e., in topological order
    for i in reversed(range(2*n)):
        if departure[i] != -1:
            print(departure[i], end=' ')
 

# Function to print adjacency list representation of a graph
def printGraph(graph):
    for src in range(len(graph.adjList)):
        # print current vertex and all its neighboring vertices
        for (dest, weight) in graph.adjList[src]:
            print(f'({src} â€”> {dest}, {weight}) ', end='')
        print()
 
 
if __name__ == '__main__':
 
    # Input: Edges in a weighted digraph (as per the above diagram)
    # Edge (x, y, w) represents an edge from `x` to `y` having weight `w`
    edges = [(0, 1, 3), (1, 4, 1), (2, 4, 1), (3, 4, 2)]
 
    # No. of vertices (labelled from 0 to 5)
    n = 5
 
    # construct a graph from a given list of edges
    graph = Graph(edges, n)
 
    # print adjacency list representation of the graph
    printGraph(graph)

    def dfs(place, dist_so_far, roads, distances):
      if (place not in distances) or (distances[place] > dist_so_far):
        distances[place] = dist_so_far
        for combo in roads[place]:
            to_city, dist = combo
            dfs(to_city, dist_so_far+dist, roads, distances)
   
    road = {'0': [('1', 3.0)], 
        '1': [('4', 1.0)], 
        '2': [('4', 1.0)], 
        '3': [('4', 2.0)]}
    
    distances = { }
    start_place = '0'
    dfs(start_place, 0.0, road, distances )

    if destination in distances :
      print("Distance from {} to {} is {}".format(start_place,destination, distances[destination]))

    print(dfs(road, 'a', 'b', 0.0))
     
    # perform topological sort
    #doTopologicalSort(graph, n)

# -*- coding: utf-8 -*-
"""
Created on Mon May 10 2021
@author: Michael Lin
"""
import collections
import functools


# Decorator
def store(func):
    cache = {}

    @functools.wraps(func)
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]

    return wrapper


class Graph:
    def __init__(self, nodes):
        self.nodes = nodes
        self.edge_list = collections.defaultdict(list)

    def add_edge(self, start, end, weight):
        """
        Add in edges to internal edge default dictionary
        :param start: starting point
        :param end: ending point
        :param weight: edge weight
        :return: None
        """
        self.edge_list[start].append((end, weight))

    def topological_sort(self, val, visited, stack):
        """
        DFS Topological sort
        :param val: starting node
        :param visited: visited tracker
        :param stack: stack
        :return: None
        """
        visited[val] = True
        if val in self.edge_list.keys():
            for node, weight in self.edge_list[val]:
                if not visited[node]:
                    self.topological_sort(node, visited, stack)
        stack.append(val)

    def shortest_path(self, start, end):
        """
        Calculate the shortest path
        :param start: starting point
        :param end: ending point
        :return: The shortest distance to the ending point and the corresponding shortest path
        """
        # If not in range, raise exception
        if end > self.nodes or start < 0:
            raise KeyError("Can't find the starting point or ending point")

        # dist_map records the shortest distance
        # visited records whether the node has been visited or not for topological sort
        # topsort_order collects topological sorted order
        # shortest_path collects the index that has the lowest distance to end point
        dist_map = [float('inf')] * self.nodes
        dist_map[start] = 0
        visited = [False] * self.nodes
        topsort_order = []
        shortest_path = collections.defaultdict(int)

        # Get the topological sorted order
        for i in range(self.nodes):
            if not visited[i]:
                self.topological_sort(start, visited, topsort_order)

        # Having the topological order, find the shortest path
        while topsort_order:
            # Original topological sort algorithm has the order reversed
            # Here we don't need to reverse since we are popping from the back anyway
            curr = topsort_order.pop()
            for node, weight in self.edge_list[curr]:
                # dist_map[node] = min(dist_map[node], dist_map[curr] + weight)
                if dist_map[node] > dist_map[curr] + weight:
                    dist_map[node] = dist_map[curr] + weight
                    # To find the path, store the index that gives us the shortest distance
                    shortest_path[node] = curr

        # Print out the path going backwards
        curr = shortest_path[end]
        res = [end, curr]
        while curr != start:
            res.append(shortest_path[curr])
            curr = shortest_path[curr]
        res.reverse()

        return dist_map[end], res

    def recurse_shortest_path(self, start, end):
        # Use decorator to store the value to speed up top-down recursion result
        @store
        def dist(node):
            if node == end:
                return 0
            # Straight forward implementation, use recursion to check the sum of weight and distance at v
            return min(w + dist(v) for v, w in self.edge_list[node])
        return dist(start)


def main():
    # Test 1
    test_graph = Graph(6)
    test_graph.add_edge(0, 1, 5)
    test_graph.add_edge(0, 2, 3)
    test_graph.add_edge(1, 3, 6)
    test_graph.add_edge(1, 2, 2)
    test_graph.add_edge(2, 4, 4)
    test_graph.add_edge(2, 5, 2)
    test_graph.add_edge(2, 3, 7)
    test_graph.add_edge(3, 4, -1)
    test_graph.add_edge(4, 5, -2)
    d1, path1 = test_graph.shortest_path(1, 5)
    dist_recursion1 = test_graph.recurse_shortest_path(1, 5)
    print("Shortest distance: {}".format(d1))
    print("Shortest path: {}".format(path1))
    print("Shortest distance using recursion: {}".format(dist_recursion1))

    # Test 2
    test_graph2 = Graph(6)
    test_graph2.add_edge(0, 1, 2)
    test_graph2.add_edge(0, 5, 9)
    test_graph2.add_edge(1, 2, 1)
    test_graph2.add_edge(1, 3, 2)
    test_graph2.add_edge(1, 5, 6)
    test_graph2.add_edge(2, 3, 7)
    test_graph2.add_edge(3, 4, 2)
    test_graph2.add_edge(3, 5, 3)
    test_graph2.add_edge(4, 5, 4)
    d2, path2 = test_graph2.shortest_path(0, 5)
    dist_recursion2 = test_graph2.recurse_shortest_path(0, 5)
    print("\nShortest distance: {}".format(d2))
    print("Shortest path: {}".format(path2))
    print("Shortest distance using recursion: {}".format(dist_recursion2))


if __name__ == '__main__':
    main()

def dfs(adj, used, order, x):
    used[x] = True
    for i in adj[x]:
        if used[i] == False:
            dfs(adj,used,order,i)
    order.insert(0,x)
    

def toposort(adj):
    used = [0] * len(adj)
    order = []
    for i in range(len(adj)):
        if used[i] == False:
            dfs(adj,used,order,i)
    return order

if __name__ == '__main__':
    input = sys.stdin.read()
    data = list(map(int, input.split()))
    n, m = data[0:2]
    data = data[2:]
    edges = list(zip(data[0:(2 * m):2], data[1:(2 * m):2]))
    adj = [[] for _ in range(n)]
    for (a, b) in edges:
        adj[a - 1].append(b - 1)
    order = toposort(adj)
    for x in order:
        print(x + 1, end=' ')